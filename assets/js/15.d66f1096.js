(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{361:function(a,t,n){"use strict";n.r(t);var v=n(42),s=Object(v.a)({},(function(){var a=this,t=a.$createElement,n=a._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"作用域"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[a._v("#")]),a._v(" 作用域")]),a._v(" "),n("p",[a._v("作用域是指特定范围，在该范围中的变量、函数等资源具有可访问性，作用域可以隔离变量，防止泄露，不同的作用域下可定义同名变量")]),a._v(" "),n("h2",{attrs:{id:"全局作用域"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#全局作用域"}},[a._v("#")]),a._v(" 全局作用域")]),a._v(" "),n("p",[a._v("在代码中任何地方都能访问到的对象，该对象拥有全局作用域。")]),a._v(" "),n("p",[a._v("以下三种情况能拥有全局作用域：")]),a._v(" "),n("ul",[n("li",[a._v("最外层的函数或者是最外层函数外声明的变量")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("var str = '全局变量'\nfunction out() {\n    console.log('最外层函数')\n}\n")])])]),n("ul",[n("li",[a._v("未声明就直接赋值的变量，会自动声明为拥有全局变量")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("function out() {\n    str = '未声明的全局变量'\n}\n")])])]),n("ul",[n("li",[a._v("window对象的内置属性，比如window.location,window.name等等")])]),a._v(" "),n("p",[a._v("全局作用域的弊端：会污染全局命名空间，容易命名冲突")]),a._v(" "),n("h2",{attrs:{id:"函数作用域"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#函数作用域"}},[a._v("#")]),a._v(" 函数作用域")]),a._v(" "),n("p",[a._v("函数作用域是指声明在函数体内的变量，该作用域变量只能在函数体范围内能访问得到。"),n("br"),a._v("\n作用域是分层的，在嵌套函数中分为外层作用域和内层作用域，其中内作用域可以访问外作用域的变量，反之却不行。")]),a._v(" "),n("p",[a._v('另外条件语句块或是循环语句块，例如if,switch,for in等等，在执行语句块("{}"中的语句)时，不会额外创建一个作用域，而是将变量保存在已存在的作用域中。')]),a._v(" "),n("h2",{attrs:{id:"块级作用域"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#块级作用域"}},[a._v("#")]),a._v(" 块级作用域")]),a._v(" "),n("p",[a._v("块级作用域是由let和const声明的变量，该变量只能在"),n("code",[a._v("{代码体}")]),a._v("中访问。"),n("br"),a._v("\n块级作用域不可重复声明，否则会报错，并且声明时，不会像var置顶。")]),a._v(" "),n("h2",{attrs:{id:"作用域链"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#作用域链"}},[a._v("#")]),a._v(" 作用域链")]),a._v(" "),n("p",[a._v("在一个函数体内引用一个变量，但是该变量未在函数体中声明，于是就像父级查询，一层层往上，直到查询到为止，没查到就报错，这种一层层往上查询的关系就叫做作用域链。")]),a._v(" "),n("p",[a._v("函数必定对应着自己的一个作用域链，这个作用域链是在函数声明时确定的，函数运行在声明时的作用域链上。")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("var value = 1;\nfunction fun() {\n    console.log(value)  //1\n}\nfunction fun1() {\n    var value = 2;\n    fun()\n}\n\nfun1()\n")])])]),n("h1",{attrs:{id:"闭包"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[a._v("#")]),a._v(" 闭包")]),a._v(" "),n("p",[a._v("含义：一个函数能访问到其他函数作用域中的数据。当一个函数嵌套了另一个函数，外部函数将内部的函数对象作为返回值返回时就会产生闭包。")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("var value = 1;\n\nfunction fun1() {\n    var value = 2;\n    function fun() {\n        return value  //2\n    }\n    return fun\n}\n\nfun1()()\n")])])]),n("p",[a._v("为什么需要闭包?"),n("br"),a._v("\n局部变量无法共享和长久的保存，而全局变量可能造成变量污染，所以我们需要有一种机制可以长久的保存变量又不会造成全局污染。")]),a._v(" "),n("p",[a._v("特点：")]),a._v(" "),n("ul",[n("li",[a._v("占用更多内存")]),a._v(" "),n("li",[a._v("不容易被释放")])]),a._v(" "),n("p",[a._v("使用闭包的注意点：")]),a._v(" "),n("ol",[n("li",[a._v("由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则很可能导致内存泄露。解决方法是在退出函数前将不使用的局部变量全部删除。")]),a._v(" "),n("li",[a._v("闭包会在父函数外部改变父函数内部变量的值。")])])])}),[],!1,null,null,null);t.default=s.exports}}]);