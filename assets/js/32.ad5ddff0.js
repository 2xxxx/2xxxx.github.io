(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{377:function(v,_,t){"use strict";t.r(_);var r=t(42),d=Object(r.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"tcp-和-udp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-和-udp"}},[v._v("#")]),v._v(" TCP 和 UDP")]),v._v(" "),t("p",[v._v("TCP和UDP是传输层很重要的了两个协议，主要用于两节点之间数据的传输。")]),v._v(" "),t("h2",{attrs:{id:"tcp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp"}},[v._v("#")]),v._v(" TCP")]),v._v(" "),t("p",[v._v("TCP全称为传输控制协议，是一个面向连接的，可靠的，基于字节流的协议。"),t("br"),v._v("\nTCP包结构：")]),v._v(" "),t("ol",[t("li",[v._v("源端口号和目的端口号；")]),v._v(" "),t("li",[v._v("序列号（seq）:每一个字节一个序号，确保了TCP传输的有序性，比如，一个报文段序号为300，报文端数据部分有100字节，那下一个报文段的序号就为400.")]),v._v(" "),t("li",[v._v("确认号 (ack) ：指明收到了下一个字节序号，表明数据准确收到了，只有值为1时才有效")]),v._v(" "),t("li",[v._v("SYN: 同步序号，用于建立连接过程。")]),v._v(" "),t("li",[v._v("FIN: finish标志，用于释放连接，为1时表示没有数据发送了，关闭本方数据流")]),v._v(" "),t("li",[v._v("16位窗口大小：滑动窗口大小，最大65535")]),v._v(" "),t("li",[v._v("16位TCP校验和、16位紧急指针")]),v._v(" "),t("li",[v._v("选项、数据(可选)")])]),v._v(" "),t("p",[v._v("特点：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("面向连接。面向连接是指两节点要经过三次握手连接后才能传输数据。")])]),v._v(" "),t("li",[t("p",[v._v("可靠。可靠是指TCP协议会确保数据传输的完整，如果有丢失则会重发。")])]),v._v(" "),t("li",[t("p",[v._v("流量控制。解决当接收端缓存区已满无法处理更多数据，而发送端还在继续发送，造成丢包的问题。"),t("br"),v._v("\n1."),t("code",[v._v("RTT算法")]),v._v("（Round Trip Time 环回时间：一个数据包发出到回来的时间）。"),t("br"),v._v("\n2."),t("code",[v._v("滑动窗口")]),v._v("。"),t("br"),v._v("\n当发送端发送数据给接收端时，接收端回复确认消息时会包含接收窗口(rwnd)大小，如果是剩余大小为0，发送端则停止发送，直到接收端处理完数据，剩余空间大于0，就通知发送端可以继续发送，为了避免接收端发送的通知丢失，发送端无法确认是否能继续发送的情况发生，发送端会每隔一段时间去询问接收端是否窗口大于0，如果是则继续发送，否则继续等待。滑动窗口最大为"),t("code",[v._v("min(rwnd, cwnd)")]),v._v("。")])]),v._v(" "),t("li",[t("p",[v._v("拥塞控制。当网络发生拥塞时，TCP会减少网络传输数据的速度和数量，缓解阻塞。"),t("br"),v._v("\n1.慢启动、拥塞避免。"),t("br"),v._v("\n这两种方法是在拥塞发生之前，增加拥塞窗口(cwnd)大小。"),t("br"),v._v(" "),t("code",[v._v("慢启动")]),v._v("算法是从小到大增加拥塞窗口大小去探测网络拥塞程度,呈指数增长，速度快。"),t("br"),v._v("\n算法核心:初始为1，每收到一个ACK则cwnd++，每经过一个RTT则cwnd=cwnd*2,当cwnd >= ssthresh时（通常ssthresh = 65535），进入拥塞避免算法。"),t("br"),v._v(" "),t("code",[v._v("拥塞避免")]),v._v("算法呈线性增长，速度慢，在不造成拥塞的情况下，找到cwnd的最优值。"),t("br"),v._v("\n算法核心：每收到一个ACK,则cwnd=cwnd+1/cwnd(cwnd>1时无增长)，每经过一个RTT则cwnd++")]),v._v(" "),t("p",[v._v("2.快重传、快恢复。"),t("br"),v._v("\n这两种是拥塞发生时的处理及恢复的处理，当发送端发现发送包失败了，就认为网络阻塞了。"),t("br"),v._v("\n丢包后，有两种重传方式："),t("br"),v._v("\n1.超时重传。"),t("br"),v._v("\n算法核心：ssthresh = cwnd/2, cwnd = 1,重新进入慢启动。"),t("br"),v._v("\n2.快速重传。"),t("br"),v._v("\n算法核心：ssthresh = cwnd/2, cwnd = cwnd/2,进入拥塞避免算法。")]),v._v(" "),t("p",[t("code",[v._v("快重传")]),v._v("是当接收端收到乱序的数据包时，会重复回复上一个包的确认信息，如果发送端连续收到三条重复的确认信息，则立即重发丢失的包。例如，发送端发送M1，接收端回复确认M1，若此时发送端发送M2丢失了，发送端再发送M3，M4，M5，接收端都是重复确认M1，发送端就会重发M2。"),t("br"),v._v(" "),t("code",[v._v("快恢复")]),v._v("是指当发送端收到三条重复信息时将ssthresh值减半，将cwnd设置为新的ssthresh的值，执行拥塞避免算法。")])])]),v._v(" "),t("h3",{attrs:{id:"三次握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[v._v("#")]),v._v(" 三次握手")]),v._v(" "),t("p",[v._v("TCP连接需要经历三次握手：")]),v._v(" "),t("ol",[t("li",[v._v("客户端发送连接请求给服务端")]),v._v(" "),t("li",[v._v("服务端接收到后发送确认信息给客户端")]),v._v(" "),t("li",[v._v("客户端接收后再发送报文给服务端建立连接")])]),v._v(" "),t("p",[v._v("提问，两次握手可以吗？"),t("br"),v._v("\n不行，因为TCP三次握手也是为了确认客户端与服务器的发送能力和接收能力正常，第一次握手证明了客户端发送能力正常，第二次握手证明服务端的接收和发送能力正常，第三次握手是为了证明客户端接收能力正常。少了任意一环都无法确认。")]),v._v(" "),t("p",[v._v("提问，握手过程中可以携带数据吗？"),t("br"),v._v("\n第三次握手的时候可以，因为第三次握手时客户端已经处于建立连接状态，服务端的接收及发送能力也是正常状态。第一次和第二次不行，因为可能会让服务器受到攻击。")]),v._v(" "),t("h3",{attrs:{id:"四次挥手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[v._v("#")]),v._v(" 四次挥手")]),v._v(" "),t("p",[v._v("TCP关闭连接需要进行四次挥手：")]),v._v(" "),t("ol",[t("li",[v._v("客户端发送关闭连接的请求给服务端")]),v._v(" "),t("li",[v._v("服务端回复确认消息给客户端")]),v._v(" "),t("li",[v._v("服务端发送完数据后，回复给客户端关闭连接的消息")]),v._v(" "),t("li",[v._v("客户端收到后发送关闭消息给服务端，并在等待2MSL后关闭连接")])]),v._v(" "),t("p",[v._v("提问，为什么需要四次挥手？"),t("br"),v._v("\n因为客户端发送关闭请求时服务端有可能还有数据没有发送完，所以会先告诉客户端收到关闭请求了，但是需要先把所有数据发送完，才会回复客户端可以关闭连接了。")]),v._v(" "),t("p",[v._v("提问，为什么客户端要等待2MSL再断开连接？"),t("br"),v._v("\n为了防止报文丢失，服务端无法收到客户端要断开连接的消息。MSL是指一个报文段的最大生存时间，如果发送的报文丢失，服务端确认超时及请求重发最大需要2MSL。")]),v._v(" "),t("h2",{attrs:{id:"udp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#udp"}},[v._v("#")]),v._v(" UDP")]),v._v(" "),t("p",[v._v("UDP全称为用户数据报文协议。是一种无连接的，不可靠的协议。"),t("br"),v._v("\n特点：")]),v._v(" "),t("ul",[t("li",[v._v("无连接。UDP在发送数据前无需进行三次握手连接，可以直接发送，且不会对数据报文进行任何拆分、拼接处理。")]),v._v(" "),t("li",[v._v("不可靠性。发送数据时不会关心对方是否有收到，且没有流量控制和拥塞控制，当网络不好时，很容易造成丢包的情况。在实时性要求高，比如直播、视频会议等情况下，具有优势。")])]),v._v(" "),t("h2",{attrs:{id:"对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对比"}},[v._v("#")]),v._v(" 对比")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th"),v._v(" "),t("th",[v._v("TCP")]),v._v(" "),t("th",[v._v("UDP")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("是否连接")]),v._v(" "),t("td",[v._v("是")]),v._v(" "),t("td",[v._v("否")])]),v._v(" "),t("tr",[t("td",[v._v("是否可靠")]),v._v(" "),t("td",[v._v("可靠")]),v._v(" "),t("td",[v._v("不可靠")])]),v._v(" "),t("tr",[t("td",[v._v("连接对象个数")]),v._v(" "),t("td",[v._v("一对一")]),v._v(" "),t("td",[v._v("一对一、一对多、多对一、多对多")])]),v._v(" "),t("tr",[t("td",[v._v("传输方式")]),v._v(" "),t("td",[v._v("面向字节流")]),v._v(" "),t("td",[v._v("面向报文")])]),v._v(" "),t("tr",[t("td",[v._v("首部开销")]),v._v(" "),t("td",[v._v("最小20字节，最大60字节")]),v._v(" "),t("td",[v._v("只有8字节，传输报文更高效")])]),v._v(" "),t("tr",[t("td",[v._v("使用场景")]),v._v(" "),t("td",[v._v("文件传输等可靠传输")]),v._v(" "),t("td",[v._v("实时性要求高的场景")])])])])])}),[],!1,null,null,null);_.default=d.exports}}]);