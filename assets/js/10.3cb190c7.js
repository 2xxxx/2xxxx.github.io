(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{356:function(t,a,s){"use strict";s.r(a);var r=s(42),n=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"垃圾回收机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收机制"}},[t._v("#")]),t._v(" 垃圾回收机制")]),t._v(" "),s("p",[t._v("原始数据类型存在栈空间中，引用类型存储在对空间中")]),t._v(" "),s("h2",{attrs:{id:"栈垃圾回收"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#栈垃圾回收"}},[t._v("#")]),t._v(" 栈垃圾回收")]),t._v(" "),s("p",[t._v("流程：当函数执行结束，js引擎通过向下移动指针来销毁该函数在栈中的执行上下文")]),t._v(" "),s("h2",{attrs:{id:"堆垃圾回收"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#堆垃圾回收"}},[t._v("#")]),t._v(" 堆垃圾回收")]),t._v(" "),s("p",[t._v("v8会把堆分为新生代和老生代两个区域，新生代存放生存时间短的对象，主要是副垃圾回收器负责垃圾回收，老生代中存放生存时间久的对象，主要负责老生代的垃圾回收。经过新生代两次垃圾回收还存活的对象会移至老生代。"),s("br"),t._v("\n以下主要是老生代垃圾回收机制。\n浏览器的堆垃圾回收机制主要分为两种："),s("strong",[t._v("标记清除")]),t._v("和"),s("strong",[t._v("引用计数")])]),t._v(" "),s("h3",{attrs:{id:"标记清除"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#标记清除"}},[t._v("#")]),t._v(" 标记清除")]),t._v(" "),s("p",[t._v("在执行环境中，当变量声明后，浏览器会为该变量分配内存，并将该变量标记为“进入执行环境”，在变量不再被调用时(例如函数执行完毕)，浏览器会将该变量标记为“离开执行环境”，这样，浏览器的回收机制会将该变量回收，并释放该变量所占的内存空间。")]),t._v(" "),s("h3",{attrs:{id:"引用计数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#引用计数"}},[t._v("#")]),t._v(" 引用计数")]),t._v(" "),s("p",[t._v("当对象被引用时就加1，引用结束时就减1，一直到该对象的引用计数为0时就清除该对象。"),s("br"),t._v("\n引用计数在某些情况下会发生死锁的问题，造成内存无法清除，比如")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" obj "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        a"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        b"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prop "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prop "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" b\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("所以大部分浏览器都是使用标记清除来回收,标记清除会从一组根元素开始遍历，遍历不到的对象说明不会再使用，可以回收了，所以上述死锁的现象，如果遍历不到a和b，这两个都会被清除。")]),t._v(" "),s("h2",{attrs:{id:"内存泄露"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存泄露"}},[t._v("#")]),t._v(" 内存泄露")]),t._v(" "),s("p",[t._v("应用程序不再需要占用内存时，由于某种原因，内存无法被回收。")]),t._v(" "),s("p",[s("strong",[t._v("泄露点")])]),t._v(" "),s("ol",[s("li",[t._v("DOM/BOM对象泄露")]),t._v(" "),s("li",[t._v("script中存在对DOM/BOM对象的引用")]),t._v(" "),s("li",[t._v("js对象泄露")]),t._v(" "),s("li",[t._v("闭包导致")])]),t._v(" "),s("p",[s("strong",[t._v("处理方法")])]),t._v(" "),s("ol",[s("li",[t._v("绑定了DOM/BOM对象的事件，在不需要调用时进行解绑，置为null")]),t._v(" "),s("li",[t._v("使用全局变量存储大量数据时，在确保用完后把它设置为null或重新定义")]),t._v(" "),s("li",[t._v("定时器在用完后进行清除")])])])}),[],!1,null,null,null);a.default=n.exports}}]);