(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{364:function(e,r,t){"use strict";t.r(r);var o=t(42),l=Object(o.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"框架架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#框架架构"}},[e._v("#")]),e._v(" 框架架构")]),e._v(" "),t("h2",{attrs:{id:"mvc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mvc"}},[e._v("#")]),e._v(" MVC")]),e._v(" "),t("p",[e._v("Model-View-Controller"),t("br"),e._v("\n模型(model): 数据保存"),t("br"),e._v("\n视图(View): 用户界面"),t("br"),e._v("\n控制器(Controller): 业务逻辑")]),e._v(" "),t("p",[e._v("MVC所有的通信都是单向的，View传送指令到Controller,Controller完成业务逻辑后要求Model改变状态，Model将新的数据发送给View,用户得到反馈")]),e._v(" "),t("h2",{attrs:{id:"mvvm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mvvm"}},[e._v("#")]),e._v(" MVVM")]),e._v(" "),t("p",[e._v("Model-View-Viewmodel,是MVC的改进版，可以解决随着业务变复杂，视图交互变复杂导致的Controller臃肿的问题。"),t("br"),e._v("\n优势： 促进前端开发与后端业务逻辑的分离，提高前端开发效率\nMVVM的核心是ViewModel层，负责转换Model中的数据对象来让数据变得更容易管理和使用，向上"),t("strong",[e._v("与视图层进行双向数据绑定")]),e._v("，向下"),t("strong",[e._v("与Model层通过请求进行数据交互")]),e._v("。")]),e._v(" "),t("ol",[t("li",[t("strong",[e._v("View")]),t("br"),e._v("\nView是视图层，也就是用户界面。主要由HTML和CSS构建")]),e._v(" "),t("li",[t("strong",[e._v("Model")]),t("br"),e._v("\nModel是指数据模型，对前端来说就是后端提供的API接口")]),e._v(" "),t("li",[t("strong",[e._v("ViewModel")]),t("br"),e._v("\nViewModel是视图数据层。在这层，前端开发者对从后端获取的Model数据进行转换处理，做二次封装，生成View层使用预期的视图数据模型。ViewModel封装的数据模型包括视图的状态和行为两部分，而Model层的数据模型只包含状态。"),t("br"),e._v("\nMVVM框架实现了双向绑定，这样ViewModel的内容会实时展现在View层，不用再通过操作DOM去更新View层。")])]),e._v(" "),t("h2",{attrs:{id:"mvp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mvp"}},[e._v("#")]),e._v(" MVP")])])}),[],!1,null,null,null);r.default=l.exports}}]);