(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{362:function(n,t,s){"use strict";s.r(t);var a=s(42),e=Object(a.a)({},(function(){var n=this,t=n.$createElement,s=n._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h1",{attrs:{id:"this的指向"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this的指向"}},[n._v("#")]),n._v(" this的指向")]),n._v(" "),s("p",[n._v("this的指向主要分为两种情况：全局上下文和函数上下文。")]),n._v(" "),s("h2",{attrs:{id:"全局上下文"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#全局上下文"}},[n._v("#")]),n._v(" 全局上下文")]),n._v(" "),s("p",[n._v("在全局上下文中，this指向的window。用var声明一个变量，那么该变量会挂载在window上,用this可以访问该变量。")]),n._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("var")]),n._v(" value "),s("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[n._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[n._v("//let value2 = 1; //let声明的变量不会挂载在window上，因为它是块级作用域。")]),n._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("function")]),n._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[n._v("fun")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n    console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[n._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),n._v("value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[n._v("//Window  1")]),n._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[n._v("// console.log(this, this.value2) //Window  undefined")]),n._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[n._v("fun")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\n")])])]),s("h2",{attrs:{id:"函数上下文"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#函数上下文"}},[n._v("#")]),n._v(" 函数上下文")]),n._v(" "),s("p",[n._v("函数上下文中主要分为三种情况：")]),n._v(" "),s("ol",[s("li",[n._v("在普通函数中，非严格模式下this指向window,严格模式下,this指向undefined")])]),n._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("function")]),n._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[n._v("fun")]),n._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n    console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[n._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),s("span",{pre:!0,attrs:{class:"token comment"}},[n._v("//window")]),n._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[n._v("fun")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\n")])])]),s("ol",{attrs:{start:"2"}},[s("li",[n._v("在构造函数中，当函数中调用了this,this指向当前函数")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var fun = function() {\n    this.value = 3\n    console.log(this) //fun {value: 3}\n}\nvar test = new fun()\nconsole.log(test.value) //3\n")])])]),s("ol",{attrs:{start:"3"}},[s("li",[n._v("在箭头函数中，没有this的绑定，如果箭头函数的外部有非箭头函数包裹它，则取最近的非箭头函数中this指向；如果没有包裹就指向window")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var fun = function outfun() {\n    console.log('外层',this); //外层 outfun{}\n    var infun = ()=> {console.log('内层', this)}; //内层 outfun{}\n    infun();\n}\nvar test = new fun();\n//外层未包裹的情况\nvar fun = ()=> {console.log('内层', this)}; //内层 window\n fun();\n")])])]),s("h2",{attrs:{id:"改变this指向"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#改变this指向"}},[n._v("#")]),n._v(" 改变this指向")]),n._v(" "),s("p",[n._v("改变this指向的方法主要有")]),n._v(" "),s("ul",[s("li",[n._v("箭头函数")]),n._v(" "),s("li",[n._v("声明变量保存this(一种解决办法，不算改变this指向)")]),n._v(" "),s("li",[n._v("new 实例化")]),n._v(" "),s("li",[n._v("call,apply,bind")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var test = {\n    num: 123,\n    outfun: function() {\n        setTimeout(function() {\n           console.log(this.num);  //undefined, 在该例中由于setTimeout是由window调用的，所以this指向的是window,无法访问到test.num\n        },1000)\n        \n\n    }\n}\ntest.outfun()\n")])])]),s("p",[n._v("修改方法：")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("//箭头函数  \nvar test = {\n    num: 123,\n    outfun: function() {\n        setTimeout(() => {\n           console.log(this.num);  //123\n        },1000)\n        \n\n    }\n}\ntest.outfun()\n\n//call,apply,bind\nvar test = {\n    num: 123,\n    outfun: function() {\n        setTimeout(function() {\n           console.log(this.num);  //123\n        }.call(test),1000)\n\n        //setTimeout(function() {\n        //   console.log(this.num);  //123\n        //}.apply(test),1000)\n\n         //setTimeout(function() {\n        //   console.log(this.num);  //123\n        //}.bind(test),1000)\n\n    }\n}\ntest.outfun()  \n\n//声明变量保存\nvar test = {\n    num: 123,\n    outfun: function() {\n        let that = this\n        setTimeout(function() {\n           console.log(that.num);  \n        },1000)\n        \n\n    }\n}\ntest.outfun()  \n")])])]),s("p",[n._v("new实例改变指向")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var fun = function outfun() {\n    console.log('外层',this); \n    var infun = ()=> {console.log('内层', this)}; \n    infun();\n}\nvar test = new fun();\n//外层 outfun{}\n//内层 outfun{}\n\nfun()\n//外层 window\n//内层 window\n")])])]),s("p",[s("strong",[n._v("call")]),n._v("\n语法：fun.call(thisArg, arg1, arg2,....)"),s("br"),n._v("\n使用：第一个参数是this的指向，传参方式是以参数列表的型式")]),n._v(" "),s("p",[s("strong",[n._v("apply")]),s("br"),n._v("\n语法：fun.call(thisArg, [arg1, arg2 ,...])"),s("br"),n._v("\n使用：第一个参数是this的指向，传参方式是数组的型式")]),n._v(" "),s("p",[n._v("ps:thisArg为null或undefined时，非严格模式下，this会指向window,严格模式下，this会指向null或undefined。当thisArg的值是基本类型number、string、boolean时，this指向变为基本类型的包装对象（如Number()等等）")]),n._v(" "),s("p",[s("strong",[n._v("bind")]),s("br"),n._v("\nbind与call,apply不一样，bind()会创建一个新的函数，在bind被调用时，新函数中的this是指向第一个参数thisArg.bind是用call和apply实现的")])])}),[],!1,null,null,null);t.default=e.exports}}]);