(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{358:function(e,t,n){"use strict";n.r(t);var a=n(42),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"es6"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#es6"}},[e._v("#")]),e._v(" ES6")]),e._v(" "),n("h2",{attrs:{id:"let和const"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#let和const"}},[e._v("#")]),e._v(" let和const")]),e._v(" "),n("p",[e._v("块级作用域。"),n("br"),e._v("\n相同点：")]),e._v(" "),n("ol",[n("li",[e._v("只在声明的执行体中有效。在全局声明时，无法挂载在window上;")]),e._v(" "),n("li",[e._v("声明不会提升，存在暂时性死区，只能声明后才能调用;")]),e._v(" "),n("li",[e._v("同一作用域中，不可重复声明。"),n("br"),e._v("\nps: 上述3点，var可以做到。"),n("br"),e._v("\n不同点：")]),e._v(" "),n("li",[e._v("const声明时就要赋值，且值为简单类型是不可更改的，为对象类型时可修改内部属性。因为const是保证声明对象所指向的内存地址里数据不改动，相当于声明一个常量而不是变量，但是当值为对象类型时，保存到内存中的是指向实际数据的指针，const只能保证指针不变，无法确保数据不变。"),n("br"),e._v("\n例如：")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('const foo = {};\nfoo.num = 111;\nconsole.log(foo.prop);  //111\n\n//将foo指向另一对象\nfoo = {} 、、TypeError: "foo" is read-only\n \n')])])]),n("p",[n("strong",[e._v("面试问题")]),n("br"),e._v("\n代码编译是会通过babel将ES6的语法转换为ES5的语法，ES5中没有const声明，请问a的值会改变吗？")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const a = 5;\neval('a=10');\n")])])]),n("h2",{attrs:{id:"箭头函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数"}},[e._v("#")]),e._v(" 箭头函数")]),e._v(" "),n("p",[e._v("直接调用父级this,具体内容在this指向一章中。")]),e._v(" "),n("h2",{attrs:{id:"解构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#解构"}},[e._v("#")]),e._v(" 解构")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let student = {name:'lw', age: 20};\nlet {newname ,newage} = student;\nconsole.log(newname,newage) //lw 20\n\nstudent = {name:'asd', age: 40};\nconsole.log(newname) //lw\n")])])]),n("p",[e._v("解构属于深拷贝")]),e._v(" "),n("h2",{attrs:{id:"字符串模板"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#字符串模板"}},[e._v("#")]),e._v(" 字符串模板")]),e._v(" "),n("p",[e._v("常用，不用写")]),e._v(" "),n("h2",{attrs:{id:"args"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#args"}},[e._v("#")]),e._v(" ...args")]),e._v(" "),n("p",[e._v("作用：")]),e._v(" "),n("ol",[n("li",[e._v("处理不定数目的参数；")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function fun(a, ...args) {\n    for(let i of args) {\n        console.log(arg);\n    }\n}\nfun(1,3,5,7,9);\n//3\n//5\n//7\n//9\n")])])]),n("ol",{attrs:{start:"2"}},[n("li",[e._v("展开数组")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let arr1 = [2,3,4];\nlet arr = [1, ...arr1, 5] //1,2,3,4,5  \n")])])]),n("h2",{attrs:{id:"模块"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#模块"}},[e._v("#")]),e._v(" 模块")]),e._v(" "),n("p",[e._v("特性：")]),e._v(" "),n("ol",[n("li",[e._v("尽量静态化，在编译时确定依赖关系，而原有的CommonJS和AMD是在运行时确定")]),e._v(" "),n("li",[e._v("输出接口与值是动态绑定关系，若是模块内部变量有变化，外部能通过接口取到实时的值")]),e._v(" "),n("li",[e._v("输入输出要处于模块顶层，不能在块级作用域中，会报错，无法做静态优化")])]),e._v(" "),n("p",[n("strong",[e._v("import 和 export")]),n("br"),e._v(" "),n("code",[e._v("export")]),e._v("是输出，可输出变量，函数，类。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("//变量\nvar str1 = 'ad',\nstr2 = 'zx';\nexport {str1, str2} \nexport var str3 = 'we' \n\n//函数  \nexport function fun1(x,y) {\n    return x + y\n}\nfunction v1() {...}\nexport {v1 as multiaddV1}\n")])])]),n("p",[n("code",[e._v("import")]),e._v("是输入，使用了export定义了对接接口后，可以通过import来加载这些模块")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import {str1,str2} from '../xxx'\n\nimport {str3 as params} from '../xxx' \n\nimport * as testmodule from './aaa'  //文件整体加载\n")])])]),n("p",[e._v("ps:import命令会提升至头部执行；import是静态执行，不能使用表达式和变量。")]),e._v(" "),n("p",[n("strong",[e._v("import动态加载")]),n("br"),e._v("\n引入import()函数，可实现动态加载。类似于Node的require,不过前者是异步加载，后者是同步加载。"),n("br"),e._v("\n适用场合：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("//1.按需加载\nbtn.addEventListener('click', e => {\n    import('../aaa').then(...)\n})\n\n//2.条件加载 \nif(condition) {\n    import('../aaa.js').then(({export1}) => {\n        console.log(export1.aa)\n    })\n}else {\n    import('../bbb.js').then(...)\n}\n\n//3.动态的模块路径 \nfunction fun() {\n    ...\n    return xxx\n}\nimport(fun()).then(...)\n")])])]),n("h2",{attrs:{id:"set和map"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#set和map"}},[e._v("#")]),e._v(" Set和Map")]),e._v(" "),n("h3",{attrs:{id:"set"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[e._v("#")]),e._v(" Set")]),e._v(" "),n("p",[e._v("类似于数组，成员的值不会重复，通常用于去重。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let arr = new Set([1, 1, 2, 3, 3]);\ncongsole.log([...arr]) //[1,2,3]\nconsole.log(arr.size)  //3\n")])])]),n("p",[e._v("ps：")]),e._v(" "),n("ol",[n("li",[e._v("Set不会进行类型转换，所以不同类型的1和'1'不会执行去重；")]),e._v(" "),n("li",[e._v("内部判断算法类似与"),n("code",[e._v("===")]),e._v(",可以判断NaN,null,undefined等简单类型，数组、对象、正则等无法去重")])]),e._v(" "),n("p",[e._v("关于Set其他方法用得不多，还有weakSet,等用到时再添加。")]),e._v(" "),n("h3",{attrs:{id:"map"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[e._v("#")]),e._v(" Map")]),e._v(" "),n("p",[e._v("类似于键值对的结构")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("//增删查改\nlet map = new Map();\nmap.set('name', 'az'); \nmap.get('name'); //az\n\nmap.has('name'); //true\nmap.delete('name);  //true\nmap.has('name');  false\nmap.clear(); //清除\n")])])]),n("p",[e._v("map也可以接受数组等具有Iterator接口且数据结构如下的数据为参数")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let map = new Map([\n    ['name', 'qw'],\n    ['age', 23]\n])\nmap.size  //2\nmap.has('name'); //true\nmap.get('name'); //qw\n")])])]),n("h4",{attrs:{id:"weakmap"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#weakmap"}},[e._v("#")]),e._v(" WeakMap")]),e._v(" "),n("p",[e._v("结构与map类似，引用对象都是弱引用，当引用对象的其他引用都清除，则释放。解决忘记删除引用可能造成的内存泄露问题。"),n("br"),e._v("\n目前尚未使用，待使用后添加。")]),e._v(" "),n("h2",{attrs:{id:"promise"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[e._v("#")]),e._v(" Promise")]),e._v(" "),n("p",[e._v("Promise是实现异步的一个对象。避免回调地狱"),n("br"),e._v(" "),n("strong",[e._v("方法")]),e._v("："),n("br"),e._v(" "),n("code",[e._v("resolve")]),e._v("，将Promise对象的状态改为成功，并传递一个参数给成功的回调函数"),n("br"),e._v(" "),n("code",[e._v("reject")]),e._v(", 将Promise对象的状态改为失败，并将错误消息传给失败的回调函数")]),e._v(" "),n("p",[n("strong",[e._v("状态")]),e._v("：")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("Fulfilled")]),e._v(",成功的状态")]),e._v(" "),n("li",[n("code",[e._v("Rejected")]),e._v(",失败的状态")]),e._v(" "),n("li",[n("code",[e._v("Pending")]),e._v(", 初始状态，进行中")])]),e._v(" "),n("p",[n("strong",[e._v("特点")])]),e._v(" "),n("ol",[n("li",[e._v("对象的状态不受外部影响。")]),e._v(" "),n("li",[e._v("状态一旦改变，就不会再变。状态改变只有两种可能："),n("code",[e._v("Pending")]),e._v(" -> "),n("code",[e._v("Fulfilled")]),e._v(", "),n("code",[e._v("Pending")]),e._v(" -> "),n("code",[e._v("Rejected")])])]),e._v(" "),n("p",[n("strong",[e._v("基本用法")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let promise = new Promise(function(resolve, reject) {\n    ...\n    if(/*success*/) {\n        resolve(value)\n    }else {\n        reject(error)\n    }\n})\npromise().then(res => {\n    console.log('成功',res)\n}).catch(err => {\n    console.log('失败',err)\n})\n")])])]),n("p",[n("strong",[e._v("promise.all()")]),n("br"),e._v("\n批量执行多个promise时使用，只有当promise.all内所有promise实例执行完毕，promise.all()的状态才会改变")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let p1 = new Promise(\n    function(resolve,reject) {\n        console.log('成功')\n    }\n)\n\nlet p2 = new Promise(\n    function(resolve,reject) {\n        console.log('成功')\n    }\n)\n\nPromise.all([p1,p2]).then(res => {\n    console.log('成功',res)\n}).catch(err => {\n    console.log('失败',err)\n})\n")])])]),n("p",[e._v("上例中任何一个promise实例任何一个执行失败都会报错，报错信息为失败的promise实例返回的错误信息")]),e._v(" "),n("p",[n("strong",[e._v("promise.race()")]),n("br"),e._v("\n用法与promise.all()类似，不同的是适用场景，promise.race()是只要其中的promise实例有一个成功，promise.race()的转台就会改变")]),e._v(" "),n("p",[n("strong",[e._v("promise异步串联")]),n("br"),e._v("\n适用场景：当多个promise实例需要按顺序执行时，使用异步串联")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function four() {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            console.log(4);\n            resolve();\n        },2000)\n    })\n}\n\nfunction three() {\n    return new Promise((resolve,reject) => {\n        console.log(3);\n        resolve(123);\n    })\n}\nfunction two(){\n\treturn new Promise(function(resolve, reject) {\n\t    console.log(2);\n        resolve();\n    });\n}\n\nfunction one(){\n\treturn new Promise(function(resolve, reject) {\n        console.log(1);\n        resolve();\n    });\n}\n\nvar p = new Promise((resolve, reject) => {\n    resolve();\n})\np.then(one)\n.then(four)\n.then(two)\n.then(three)\n.then((res) => {\n    console.log(res)\n})\n//1\n//4\n//2\n//3\n//123\n")])])]),n("h2",{attrs:{id:"proxy"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#proxy"}},[e._v("#")]),e._v(" Proxy")]),e._v(" "),n("p",[e._v("Proxy意思为代理，在ES6中作用是给目标对象的访问进行拦截，并在内部做相关处理后再返回结果。"),n("br"),e._v("\nProxy有两个参数，target和handler, target是被代理的对象，handler是对代理对象的操作。\n"),n("strong",[e._v("基本用法")]),e._v("：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let obj = new Proxy({}, {\n    get: function(target, key) {\n        console.log(`get ${key}`)\n        return target[key]\n    }, \n    set: function(target, key, value) {\n        console.log(`set ${key}`);\n        target[key] = value;\n        return target[key]\n    }\n})\nobj.count = 1;\n//set count \n//1\n++obj.count\n//get count\n//set count\n//2\n")])])]),n("p",[e._v("handler是空对象时，没有拦截效果，访问handler就是访问target")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let target = {};\nlet handler = {}; \nlet proxy = new Proxy(target, handler);\nproxy.a = 1;\nconsole.log(target.a) //1\n")])])]),n("p",[e._v("同一个拦截器函数可以拦截多个操作，以下Proxy支持的拦截操作：")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("get(target,propKey,receiverv)")]),e._v(",拦截读取，receiver是可选属性")]),e._v(" "),n("li",[n("code",[e._v("set(target,propKey,value,receiver)")]),e._v(",拦截设置，返回布尔值")]),e._v(" "),n("li",[n("code",[e._v("has(target,propKey)")]),e._v(",拦截"),n("code",[e._v("propKey in proxy")]),e._v(",返回布尔值")]),e._v(" "),n("li",[n("code",[e._v("deleteProperty(target,propKey)")]),e._v(", 拦截"),n("code",[e._v("delete proxy[propKey]")]),e._v(",返回布尔值")]),e._v(" "),n("li",[n("code",[e._v("ownKeys(target)")]),e._v(",拦截"),n("code",[e._v("Object.getOwnPropertyNames(proxy)")]),e._v("、"),n("code",[e._v("Object.getOwnPropertySymbols(proxy)")]),e._v("、"),n("code",[e._v("Object.keys(proxy)")]),e._v(",返回一个数组（目标对象所有自身属性的属性名）")]),e._v(" "),n("li",[n("code",[e._v("apply(target,object,args)")]),e._v(",拦截Proxy实例,并将其作为函数调用")]),e._v(" "),n("li",[n("code",[e._v("construct(target,args)")]),e._v(",拦截Proxy实例,并将其作为构造函数调用")])])])}),[],!1,null,null,null);t.default=r.exports}}]);