# http协议  
http是超文本传输协议，用于客户端和服务器之间的通信，默认80端口用明文进行传输。     
一个http请求报文由  
**请求行**(请求方法、URL 、 协议版本)、  
**请求头部**(Host:服务器地址、User-Agent:发送请求的应用程序名称、Connection:指定与连接相关的属性、Accept-Charset:可接收的编码格式、Accept-Encoding:可接收的数据压缩格式、Accept-Language:可接收语言)、  
**请求数据**(在POST中使用)组成
 请求头：  
 ```json
GET /HTTP/1.0        //协议版本
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.135 Safari/537.36  
Accept: */*     //接收格式
 ```
**请求方法**
http/1.1定义的请求方法有8中：`GET`(完整请求一个资源),`POST`(提交表单),`PUT`(上传文件)，`DELETE`(删除),`PATCH`、`HEAD`(仅请求响应头部)，`OPTIONS`(返回请求的资源所支持的方法)，`TRACE`(追踪一个资源请求中间所经过的代理)。  
其中常用的是GET和POST，GET和POST的区别：  
1. GET将参数包含在URL中，而POST通过requet body传递参数；  
2. GET请求只能进行url编码，而POST支持多种编码格式;  
3. GET请求传送的参数有大小限制，不能大于2kb，post没有；  
4. 浏览器执行XMLRequest Post请求时分两步，先发HTTP Header,再发data，要发两个TCP数据包，得发两次。而GET只用一个TCP数据包(`header+data`) 发送数据。（ps:火狐POST时只发送一次）

响应报文由  
**状态行**(协议版本、状态码、状态码描述)、  
**响应头部**(Server: 服务器应用程序软件的名称和版本、Content-Type: 响应数据类型、Content-Length:长度、Content-Charset:数据使用的编码、Content-Encoding:数据的压缩格式、Content-Language:使用的语言)、  
**响应数据**组成

回应头：  
```json
HTTP/1.0 200OK    //状态码
Content-Type: image/gif
Content-Length: 43
Expires:Thu, 05 Dec 1997 16:00:00 GMT  
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84
```  
**Expires**和**Last-modified**是[浏览器缓存](../browser/storage)中强缓存和协商缓存的判断依据。  

不足：每个TCP连接只能发送一个请求，TCP连接每次都要经过三次握手和四次挥手，连接成本较高，导致http1.0版本性能较差。  
为了解决上述问题，可以在请求头加上`Connection:keep-alive`(非标准字段),要求服务器不要关闭TCP连接，实现TCP复用，知道客户端通知服务器关闭连接。 


## http1.1 
http/1.1版本进一步完善了http协议。做出许多改进：  
1. **持久连接**。1.1版本默认不关闭TCP连接，可以复用，当需要关闭时，客户端发送`Connection:close`字段。  
同一个域名，大多浏览器最多允许同时建立6个连接  
2. **管道机制**。同一个TCP连接内，客户端可以同时发送多个请求，服务端按请求的先后顺序依次回应请求。之前是要等前一个请求回复后才能再发送请求，这样将大大提高效率。  
3. **Content-Length**。表示服务端回复数据的长度，在TCP的多个响应中区分数据包对应哪个响应。  
4. **分块传输编码**。数据分块发送，提高发送效率。由头信息中`Transfer-Encoding:chunked`判断。  
5. 其他。  
    * 新增`PUT`、`PATCH`、`HEAD`、`OPTIONS`、`DELETE`
    * 请求头新增`HOST`字段，指定服务器域名。
  
不足：可能导致**队头阻塞**，虽然1.1是可以同时发送，但是响应是回复完一个再回复下一个，若当前回复过慢，就会造成后续阻塞。  


## http2.0  
特点：  
1. **二进制协议**。头信息和数据体都是二进制，二进制传输代替明文传输，报文消息划为数据帧，帧是数据最小的传输单位。  
2. **多路复用**。在一个TCP连接中，客户端和服务端可以同时发送响应多个请求，不用按顺序，避免了队头阻塞。  
原理：每个请求都是一个数据流，响应数据会划分成更小的单位帧，每帧都会携带数据流的stream indentifier标识，在一个TCP连接上，可以不断发送帧，客户端接收后会根据stream indentifier来拼接，确定是哪一个请求的回复  
3. **头信息压缩**。  
原因：http协议没有状态，每次请求会带上所有信息，会造成字段重复。  
优化： 头信息使用`gzip`或 `compress`压缩后再发送；客户端与服务器同时维护一张头信息表，里面存有所有字段，生成索引，发送请求时就发送索引。  
4.**服务器推送**。服务器主动向客户端发送资源。  
使用场景：客户端请求资源后，服务器主动推送相关资源，这样客户端就无需再发送后续请求。  


**提问**，http1.x可以实现多路复用吗？ 
不能。  
1. http1.x是序列和阻塞机制，一次执行一个请求，如果前一个请求处理事件过长，会阻塞后一个请求的处理；
2. http1.x是文本传输，而不是二进制传输，没有流的概念，倘若有多路请求，无法区分哪个响应对应哪个请求，也就无法进行多路复用

HTTP2可以多路复用，
多路复用归功于， HTTP/2 中的 帧（frame）和流（stream）。帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。就是在一个 TCP 连接中可以存在多条流。
而Http 1.x 并没有这个标识

  
## http3.0    
http3.0（QUIC）传输将使用UDP协议，因为UDP传输不需要连接且传输速度快，对于传输不可靠的问题，会在外层再重新封装。

## https
https是经过SSL或TLS加密过的协议，是以安全为目标的http协议。  
优点：  
1. 加密后传输，更加安全；  
2. 在谷歌浏览器中,https协议的网站搜索排名更高。  

缺点：  
1. 加载时间会比http协议的网站更长   


**https握手过程**  
1. 与服务器建立443端口连接  
2. SSL加密  
3. 发送加密请求  
4. 发送加密响应  
5. 关闭SSL
6. 关闭TCP连接   
详细：  
* 客户端发送浏览器支持的加密方式与一个随机数给服务端  
* 服务端接收后返回一个随机数并根据客户端提供的加密方式运用公钥对随机数进行加密，并且把公钥对应的数字证书一起发送给客户端。  
* 客户端接收后向证书中心(一般内置在浏览器中)验证数字证书是否有效，并获取对应公钥，再用公钥加密一个随机数发给服务端。  
* 服务端收到后用自己的私钥进行解密，并用双方约定的加密方式加密三次互发的随机数生成对话密钥，之后两端对话就用该对话密钥加密。  
客户端与服务端连接使用的是非对称加密，对话使用的是对称加密。  

**如何劫持https的请求**
1. 在客户端去请求域名对应IP时，**对DNS解析进行拦截**，返回黑客伪造的IP给客户端，客户端会访问到黑客伪造的网站。  
2. **攻破CA机构的证书服务器，伪造一套SSL秘钥对和证书**，https连接时服务端将伪造的数字证书发送给客户端，与之进行连接，一般来说是无法攻破的。  


## websocket  
依赖于TCP协议，通过HTTP1.1协议的101状态码进行握手。是属于全双工类型通信，客户端和服务端双方都能主动发送。传输格式有数据、文本、二进制。  
四个阶段：onopen,onmessage,onclose,onerror
```js
var ws = new Websocket(`ws://${hostname}:${port}/websocket`);
ws.open = function(e) {
    //连接成功
}
ws.onmessage = function(e) {
    //接收服务端返回的数据
}
ws.onerror = function(e) {
    //报错
}
ws.onclose = function(e) {
    //关闭连接
}
ws.send() //发送请求
```
优点：  
1. 消息实时  
2. 是一种有状态的协议，通信时可省略部分状态信息  
3. 支持二进制


## 状态码  
**状态码类型**：  
1. `1**`：信息。服务器收到请求，并需要用户继续操作  
2. `2**`: 成功。  
3. `3**`: 重定向。  
4. `4**`: 客户端错误。  
5. `5**`：服务器错误。  

**常用状态码**
|状态码 |名称          |描述                   |  
|-------|--------------|-----------------------|
|101   |Switching Protocols|切换协议    |
|200   |Ok                |请求成功               |
|204   |No Content           |无内容              |
|301   |Moved Permanently  |永久重定向    |  
|302   |Found              |临时重定向      |
|400   |Bad Request        |客户端请求有语法错误，服务器无法理解|
|401   |Unauthorized       |用户未鉴权，需要认证身份 |
|403   |Forbidden          |服务端拒绝执行请求，大概率是因为没有权限|
|404   |Not Found          |资源未找到      |
|500   |Internal Server Error|服务器内部错误    |
|503   |Service Unavailable|由于超载或者系统维护，服务端暂时无法处理请求|

301与302的差异：  
301永久重定向，使用场景是网站需要更换域名。客户端和搜索引擎可以对跳转后的地址进行缓存，下一次不必发这个请求。  
302临时重定向，使用场景是首页临时改为活动页等等。客户端必须请求原链接  

ps:尽量使用301跳转，302有网址劫持的隐患，
由于302语义不明确，http1.1又针对302细化出了303和307，区别是：当用POST请求新的URL时，303会直接改用为GET方法请求，307会询问用户是否用GET请求；当用GET请求新的URL时，两者表现一样。  

