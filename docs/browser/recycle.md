# 垃圾回收机制    
原始数据类型存在栈空间中，引用类型存储在对空间中   
## 栈垃圾回收
流程：当函数执行结束，js引擎通过向下移动指针来销毁该函数在栈中的执行上下文

## 堆垃圾回收   
v8会把堆分为新生代和老生代两个区域，新生代存放生存时间短的对象，主要是副垃圾回收器负责垃圾回收，老生代中存放生存时间久的对象，主要负责老生代的垃圾回收。经过新生代两次垃圾回收还存活的对象会移至老生代。  
以下主要是老生代垃圾回收机制。 
浏览器的堆垃圾回收机制主要分为两种：**标记清除**和**引用计数**  

### 标记清除  
在执行环境中，当变量声明后，浏览器会为该变量分配内存，并将该变量标记为“进入执行环境”，在变量不再被调用时(例如函数执行完毕)，浏览器会将该变量标记为“离开执行环境”，这样，浏览器的回收机制会将该变量回收，并释放该变量所占的内存空间。  

### 引用计数  
当对象被引用时就加1，引用结束时就减1，一直到该对象的引用计数为0时就清除该对象。  
引用计数在某些情况下会发生死锁的问题，造成内存无法清除，比如  
```js
    var obj = {
        a: {},
        b: {},
        a.prop = a,
        b.prop = b
    }
```  
所以大部分浏览器都是使用标记清除来回收,标记清除会从一组根元素开始遍历，遍历不到的对象说明不会再使用，可以回收了，所以上述死锁的现象，如果遍历不到a和b，这两个都会被清除。  

## 内存泄露   
应用程序不再需要占用内存时，由于某种原因，内存无法被回收。 

**泄露点**  
1. DOM/BOM对象泄露  
2. script中存在对DOM/BOM对象的引用  
3. js对象泄露  
4. 闭包导致  


**处理方法**  
1. 绑定了DOM/BOM对象的事件，在不需要调用时进行解绑，置为null   
2. 使用全局变量存储大量数据时，在确保用完后把它设置为null或重新定义  
3. 定时器在用完后进行清除   
