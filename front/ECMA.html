<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ES6 | 学习笔记</title>
    <meta name="generator" content="VuePress 1.5.3">
    
    <meta name="description" content="xcc的备忘笔记">
    <link rel="preload" href="/assets/css/0.styles.abfd12c2.css" as="style"><link rel="preload" href="/assets/js/app.b75bf609.js" as="script"><link rel="preload" href="/assets/js/2.591daaf2.js" as="script"><link rel="preload" href="/assets/js/12.ad7cc64c.js" as="script"><link rel="prefetch" href="/assets/js/10.a2d21ceb.js"><link rel="prefetch" href="/assets/js/11.ac74d8f6.js"><link rel="prefetch" href="/assets/js/13.9d5d45ca.js"><link rel="prefetch" href="/assets/js/14.c8abe1b6.js"><link rel="prefetch" href="/assets/js/15.d66f1096.js"><link rel="prefetch" href="/assets/js/16.fa624655.js"><link rel="prefetch" href="/assets/js/17.83440fd8.js"><link rel="prefetch" href="/assets/js/18.d67bab65.js"><link rel="prefetch" href="/assets/js/19.274ab517.js"><link rel="prefetch" href="/assets/js/20.c2baf4ab.js"><link rel="prefetch" href="/assets/js/21.2ad2b794.js"><link rel="prefetch" href="/assets/js/22.58caa96f.js"><link rel="prefetch" href="/assets/js/23.4eb6cb2b.js"><link rel="prefetch" href="/assets/js/3.dbe1ca4b.js"><link rel="prefetch" href="/assets/js/4.3b6a7e49.js"><link rel="prefetch" href="/assets/js/5.bc6e1aa4.js"><link rel="prefetch" href="/assets/js/6.569a4170.js"><link rel="prefetch" href="/assets/js/7.6d77f350.js"><link rel="prefetch" href="/assets/js/8.66ff56d1.js"><link rel="prefetch" href="/assets/js/9.50a845cf.js">
    <link rel="stylesheet" href="/assets/css/0.styles.abfd12c2.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">学习笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/front/" class="nav-link router-link-active">
  笔记
</a></div><div class="nav-item"><a href="https://github.com/2xxxx" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/front/" class="nav-link router-link-active">
  笔记
</a></div><div class="nav-item"><a href="https://github.com/2xxxx" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JavaScript基础</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/front/" aria-current="page" class="sidebar-link">定义</a></li><li><a href="/front/variable.html" class="sidebar-link">变量和类型</a></li><li><a href="/front/prototype.html" class="sidebar-link">原型和原型链</a></li><li><a href="/front/scope.html" class="sidebar-link">作用域</a></li><li><a href="/front/ECMA.html" aria-current="page" class="active sidebar-link">ES6</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/ECMA.html#let和const" class="sidebar-link">let和const</a></li><li class="sidebar-sub-header"><a href="/front/ECMA.html#箭头函数" class="sidebar-link">箭头函数</a></li><li class="sidebar-sub-header"><a href="/front/ECMA.html#解构" class="sidebar-link">解构</a></li><li class="sidebar-sub-header"><a href="/front/ECMA.html#字符串模板" class="sidebar-link">字符串模板</a></li><li class="sidebar-sub-header"><a href="/front/ECMA.html#args" class="sidebar-link">...args</a></li><li class="sidebar-sub-header"><a href="/front/ECMA.html#模块" class="sidebar-link">模块</a></li><li class="sidebar-sub-header"><a href="/front/ECMA.html#set和map" class="sidebar-link">Set和Map</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/ECMA.html#set" class="sidebar-link">Set</a></li><li class="sidebar-sub-header"><a href="/front/ECMA.html#map" class="sidebar-link">Map</a></li></ul></li><li class="sidebar-sub-header"><a href="/front/ECMA.html#promise" class="sidebar-link">Promise</a></li><li class="sidebar-sub-header"><a href="/front/ECMA.html#proxy" class="sidebar-link">Proxy</a></li></ul></li><li><a href="/front/this.html" class="sidebar-link">this的指向</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>浏览器基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>网络基础</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="es6"><a href="#es6" class="header-anchor">#</a> ES6</h1> <h2 id="let和const"><a href="#let和const" class="header-anchor">#</a> let和const</h2> <p>块级作用域。<br>
相同点：</p> <ol><li>只在声明的执行体中有效。在全局声明时，无法挂载在window上;</li> <li>声明不会提升，存在暂时性死区，只能声明后才能调用;</li> <li>同一作用域中，不可重复声明。<br>
ps: 上述3点，var可以做到。<br>
不同点：</li> <li>const声明时就要赋值，且值为简单类型是不可更改的，为对象类型时可修改内部属性。因为const是保证声明对象所指向的内存地址里数据不改动，相当于声明一个常量而不是变量，但是当值为对象类型时，保存到内存中的是指向实际数据的指针，const只能保证指针不变，无法确保数据不变。<br>
例如：</li></ol> <div class="language- extra-class"><pre class="language-text"><code>const foo = {};
foo.num = 111;
console.log(foo.prop);  //111

//将foo指向另一对象
foo = {} 、、TypeError: &quot;foo&quot; is read-only
 
</code></pre></div><p><strong>面试问题</strong><br>
代码编译是会通过babel将ES6的语法转换为ES5的语法，ES5中没有const声明，请问a的值会改变吗？</p> <div class="language- extra-class"><pre class="language-text"><code>const a = 5;
eval('a=10');
</code></pre></div><h2 id="箭头函数"><a href="#箭头函数" class="header-anchor">#</a> 箭头函数</h2> <p>直接调用父级this,具体内容在this指向一章中。</p> <h2 id="解构"><a href="#解构" class="header-anchor">#</a> 解构</h2> <div class="language- extra-class"><pre class="language-text"><code>let student = {name:'lw', age: 20};
let {newname ,newage} = student;
console.log(newname,newage) //lw 20

student = {name:'asd', age: 40};
console.log(newname) //lw
</code></pre></div><p>解构属于深拷贝</p> <h2 id="字符串模板"><a href="#字符串模板" class="header-anchor">#</a> 字符串模板</h2> <p>常用，不用写</p> <h2 id="args"><a href="#args" class="header-anchor">#</a> ...args</h2> <p>作用：</p> <ol><li>处理不定数目的参数；</li></ol> <div class="language- extra-class"><pre class="language-text"><code>function fun(a, ...args) {
    for(let i of args) {
        console.log(arg);
    }
}
fun(1,3,5,7,9);
//3
//5
//7
//9
</code></pre></div><ol start="2"><li>展开数组</li></ol> <div class="language- extra-class"><pre class="language-text"><code>let arr1 = [2,3,4];
let arr = [1, ...arr1, 5] //1,2,3,4,5  
</code></pre></div><h2 id="模块"><a href="#模块" class="header-anchor">#</a> 模块</h2> <p>特性：</p> <ol><li>尽量静态化，在编译时确定依赖关系，而原有的CommonJS和AMD是在运行时确定</li> <li>输出接口与值是动态绑定关系，若是模块内部变量有变化，外部能通过接口取到实时的值</li> <li>输入输出要处于模块顶层，不能在块级作用域中，会报错，无法做静态优化</li></ol> <p><strong>import 和 export</strong><br> <code>export</code>是输出，可输出变量，函数，类。</p> <div class="language- extra-class"><pre class="language-text"><code>//变量
var str1 = 'ad',
str2 = 'zx';
export {str1, str2} 
export var str3 = 'we' 

//函数  
export function fun1(x,y) {
    return x + y
}
function v1() {...}
export {v1 as multiaddV1}
</code></pre></div><p><code>import</code>是输入，使用了export定义了对接接口后，可以通过import来加载这些模块</p> <div class="language- extra-class"><pre class="language-text"><code>import {str1,str2} from '../xxx'

import {str3 as params} from '../xxx' 

import * as testmodule from './aaa'  //文件整体加载
</code></pre></div><p>ps:import命令会提升至头部执行；import是静态执行，不能使用表达式和变量。</p> <p><strong>import动态加载</strong><br>
引入import()函数，可实现动态加载。类似于Node的require,不过前者是异步加载，后者是同步加载。<br>
适用场合：</p> <div class="language- extra-class"><pre class="language-text"><code>//1.按需加载
btn.addEventListener('click', e =&gt; {
    import('../aaa').then(...)
})

//2.条件加载 
if(condition) {
    import('../aaa.js').then(({export1}) =&gt; {
        console.log(export1.aa)
    })
}else {
    import('../bbb.js').then(...)
}

//3.动态的模块路径 
function fun() {
    ...
    return xxx
}
import(fun()).then(...)
</code></pre></div><h2 id="set和map"><a href="#set和map" class="header-anchor">#</a> Set和Map</h2> <h3 id="set"><a href="#set" class="header-anchor">#</a> Set</h3> <p>类似于数组，成员的值不会重复，通常用于去重。</p> <div class="language- extra-class"><pre class="language-text"><code>let arr = new Set([1, 1, 2, 3, 3]);
congsole.log([...arr]) //[1,2,3]
console.log(arr.size)  //3
</code></pre></div><p>ps：</p> <ol><li>Set不会进行类型转换，所以不同类型的1和'1'不会执行去重；</li> <li>内部判断算法类似与<code>===</code>,可以判断NaN,null,undefined等简单类型，数组、对象、正则等无法去重</li></ol> <p>关于Set其他方法用得不多，还有weakSet,等用到时再添加。</p> <h3 id="map"><a href="#map" class="header-anchor">#</a> Map</h3> <p>类似于键值对的结构</p> <div class="language- extra-class"><pre class="language-text"><code>//增删查改
let map = new Map();
map.set('name', 'az'); 
map.get('name'); //az

map.has('name'); //true
map.delete('name);  //true
map.has('name');  false
map.clear(); //清除
</code></pre></div><p>map也可以接受数组等具有Iterator接口且数据结构如下的数据为参数</p> <div class="language- extra-class"><pre class="language-text"><code>let map = new Map([
    ['name', 'qw'],
    ['age', 23]
])
map.size  //2
map.has('name'); //true
map.get('name'); //qw
</code></pre></div><h4 id="weakmap"><a href="#weakmap" class="header-anchor">#</a> WeakMap</h4> <p>结构与map类似，引用对象都是弱引用，当引用对象的其他引用都清除，则释放。解决忘记删除引用可能造成的内存泄露问题。<br>
目前尚未使用，待使用后添加。</p> <h2 id="promise"><a href="#promise" class="header-anchor">#</a> Promise</h2> <p>Promise是实现异步的一个对象。避免回调地狱<br> <strong>方法</strong>：<br> <code>resolve</code>，将Promise对象的状态改为成功，并传递一个参数给成功的回调函数<br> <code>reject</code>, 将Promise对象的状态改为失败，并将错误消息传给失败的回调函数</p> <p><strong>状态</strong>：</p> <ul><li><code>Fulfilled</code>,成功的状态</li> <li><code>Rejected</code>,失败的状态</li> <li><code>Pending</code>, 初始状态，进行中</li></ul> <p><strong>特点</strong></p> <ol><li>对象的状态不受外部影响。</li> <li>状态一旦改变，就不会再变。状态改变只有两种可能：<code>Pending</code> -&gt; <code>Fulfilled</code>, <code>Pending</code> -&gt; <code>Rejected</code></li></ol> <p><strong>基本用法</strong></p> <div class="language- extra-class"><pre class="language-text"><code>let promise = new Promise(function(resolve, reject) {
    ...
    if(/*success*/) {
        resolve(value)
    }else {
        reject(error)
    }
})
promise().then(res =&gt; {
    console.log('成功',res)
}).catch(err =&gt; {
    console.log('失败',err)
})
</code></pre></div><p><strong>promise.all()</strong><br>
批量执行多个promise时使用，只有当promise.all内所有promise实例执行完毕，promise.all()的状态才会改变</p> <div class="language- extra-class"><pre class="language-text"><code>let p1 = new Promise(
    function(resolve,reject) {
        console.log('成功')
    }
)

let p2 = new Promise(
    function(resolve,reject) {
        console.log('成功')
    }
)

Promise.all([p1,p2]).then(res =&gt; {
    console.log('成功',res)
}).catch(err =&gt; {
    console.log('失败',err)
})
</code></pre></div><p>上例中任何一个promise实例任何一个执行失败都会报错，报错信息为失败的promise实例返回的错误信息</p> <p><strong>promise.race()</strong><br>
用法与promise.all()类似，不同的是适用场景，promise.race()是只要其中的promise实例有一个成功，promise.race()的转台就会改变</p> <p><strong>promise异步串联</strong><br>
适用场景：当多个promise实例需要按顺序执行时，使用异步串联</p> <div class="language- extra-class"><pre class="language-text"><code>function four() {
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            console.log(4);
            resolve();
        },2000)
    })
}

function three() {
    return new Promise((resolve,reject) =&gt; {
        console.log(3);
        resolve(123);
    })
}
function two(){
	return new Promise(function(resolve, reject) {
	    console.log(2);
        resolve();
    });
}

function one(){
	return new Promise(function(resolve, reject) {
        console.log(1);
        resolve();
    });
}

var p = new Promise((resolve, reject) =&gt; {
    resolve();
})
p.then(one)
.then(four)
.then(two)
.then(three)
.then((res) =&gt; {
    console.log(res)
})
//1
//4
//2
//3
//123
</code></pre></div><h2 id="proxy"><a href="#proxy" class="header-anchor">#</a> Proxy</h2> <p>Proxy意思为代理，在ES6中作用是给目标对象的访问进行拦截，并在内部做相关处理后再返回结果。<br>
Proxy有两个参数，target和handler, target是被代理的对象，handler是对代理对象的操作。
<strong>基本用法</strong>：</p> <div class="language- extra-class"><pre class="language-text"><code>let obj = new Proxy({}, {
    get: function(target, key) {
        console.log(`get ${key}`)
        return target[key]
    }, 
    set: function(target, key, value) {
        console.log(`set ${key}`);
        target[key] = value;
        return target[key]
    }
})
obj.count = 1;
//set count 
//1
++obj.count
//get count
//set count
//2
</code></pre></div><p>handler是空对象时，没有拦截效果，访问handler就是访问target</p> <div class="language- extra-class"><pre class="language-text"><code>let target = {};
let handler = {}; 
let proxy = new Proxy(target, handler);
proxy.a = 1;
console.log(target.a) //1
</code></pre></div><p>同一个拦截器函数可以拦截多个操作，以下Proxy支持的拦截操作：</p> <ul><li><code>get(target,propKey,receiverv)</code>,拦截读取，receiver是可选属性</li> <li><code>set(target,propKey,value,receiver)</code>,拦截设置，返回布尔值</li> <li><code>has(target,propKey)</code>,拦截<code>propKey in proxy</code>,返回布尔值</li> <li><code>deleteProperty(target,propKey)</code>, 拦截<code>delete proxy[propKey]</code>,返回布尔值</li> <li><code>ownKeys(target)</code>,拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>,返回一个数组（目标对象所有自身属性的属性名）</li> <li><code>apply(target,object,args)</code>,拦截Proxy实例,并将其作为函数调用</li> <li><code>construct(target,args)</code>,拦截Proxy实例,并将其作为构造函数调用</li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">8/24/2020, 8:10:12 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/front/scope.html" class="prev">
        作用域
      </a></span> <span class="next"><a href="/front/this.html">
        this的指向
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.b75bf609.js" defer></script><script src="/assets/js/2.591daaf2.js" defer></script><script src="/assets/js/12.ad7cc64c.js" defer></script>
  </body>
</html>
